import settings as cfg
from machine import Pin, SPI
import lib.gc9a01py as gc9a01
import math

#constants
blue=gc9a01.color565(47,32,245)

class CircularScreen:
    
    def __init__(self,sck=None,mosi=None,dc=None,cs=None,reset=None,power=None,baudrate=None):
        baudrate=baudrate if baudrate is not None else cfg.SPI_CLOCK
        sck=sck if sck is not None else cfg.SCR_SCK
        mosi=mosi if mosi is not None else cfg.SCR_MOSI
        self.dc=dc if dc is not None else cfg.SCR_DC
        self.cs=cs if cs is not None else cfg.SCR_CS
        self.reset=reset if reset is not None else cfg.SCR_RESET
        self.power_pin=power if power is not None else cfg.SCR_POW
        #lookup for screen metrics, with font height as the key
        self.screen_info=dict()

        self.spi = SPI(1, baudrate=baudrate, sck=sck, mosi=mosi)
        print(self.spi)
        
    def set_idle(self,idle):
        print("Idle transition: " + str(idle))
        Pin(self.power_pin,Pin.OUT).value(0 if idle else 1)
        
    def init_screen(self):
        Pin(self.power_pin,Pin.OUT).value(1)
        self.tft = gc9a01.GC9A01(
            self.spi,
            dc=self.dc,
            cs=self.cs,
            reset=self.reset,
            backlight=None,#Pin(7, Pin.OUT),
            rotation=0)
        self.tft.fill(blue)

    def show(self,text,fonts):
        self.tft.fill(blue)
        for font in fonts:
            layout=self.layout_text_circular(text,font.WIDTH,font.HEIGHT)
            if layout is None:
                continue
            for line in layout:
                self.tft.text(font,line[2],
                    line[0],
                    line[1],
                    gc9a01.WHITE,blue
                )
            return

    def _get_line_positions(self,font_height):
        #look up screen metrics from previous runs:
        if font_height not in self.screen_info:
            print("create screen metrics")
            screen_diameter=self.tft.height - 10
            radius = screen_diameter / 2
            center_y = radius

            # Build up vertical line positions (top to bottom)
            max_lines = int(screen_diameter / font_height)
            start_y = center_y - (max_lines / 2) * font_height
            self.screen_info[font_height]=[start_y + i * font_height for i in range(max_lines)]
        return self.screen_info[font_height]

    def layout_text_circular(self,
        text,
        font_width,
        font_height
    ):
    #this function generated by GPT. And now refactored.
        """
        Wrap and center text for a circular screen.

        :param text: The full text to render.
        :param font_width: Width of each character in pixels.
        :param font_height: Height of each text line in pixels.
        :param screen_diameter: Diameter of the circular screen in pixels.
        :return: A list of (x, y, line_text) tuples.
        """
        words = text.split()
        lines = []
        i = 0
        screen_diameter=self.tft.height-10
        radius=screen_diameter/2
        y_positions=self._get_line_positions(font_height)

        current_line = ""
        word_index = 0

        for y in y_positions:
            dy = abs(y - radius)
            if dy >= radius:
                continue  # Outside circle

            max_line_pixel_width = 2 * math.sqrt(radius**2 - dy**2)
            max_chars = int(max_line_pixel_width / font_width)

            line = ""
            while word_index < len(words):
                test_line = line + (" " if line else "") + words[word_index]
                if len(test_line) <= max_chars:
                    line = test_line
                    word_index += 1
                else:
                    break

            if line:
                line_pixel_width = len(line) * font_width
                x = (screen_diameter - line_pixel_width) / 2
                lines.append([int(x)+5, int(y)+5, line])

            if word_index >= len(words):
                break

        if word_index < len(words):
            return None
        #eliminate gaps
        for i in range(1,len(lines)):
            if lines[i][1]-lines[i-1][1] > font_height:
                for j in range(0,i):
                    lines[j][1]+=font_height
        #vertically centre
        v_shift=int(radius - (lines[-1][1] + font_height - lines[0][1])/2)
        v_shift-=lines[0][1]
        if v_shift > 0:
            for line in lines:
                line[1]+=v_shift
        return lines

