import settings as cfg
from machine import Pin, SPI
import hardware.gc9a01py as gc9a01
import math

#constants
blue=gc9a01.color565(47,32,245)

class CircularScreen:
    
    def __init__(self,sck=None,mosi=None,dc=None,cs=None,reset=None,power=None,baudrate=None):
        baudrate=baudrate if baudrate is not None else cfg.SPI_CLOCK
        sck=sck if sck is not None else cfg.SCR_SCK
        mosi=mosi if mosi is not None else cfg.SCR_MOSI
        self.dc=dc if dc is not None else cfg.SCR_DC
        self.cs=cs if cs is not None else cfg.SCR_CS
        self.reset=reset if reset is not None else cfg.SCR_RESET
        self.power_pin=power if power is not None else cfg.SCR_POW

        self.spi = SPI(1, baudrate=baudrate, sck=sck, mosi=mosi)
        print(self.spi)
        
    def set_idle(self,idle):
        print("Idle transition: " + str(idle))
        Pin(self.power_pin,Pin.OUT).value(0 if idle else 1)
        
    def init_screen(self):
        Pin(self.power_pin,Pin.OUT).value(1)
        self.tft = gc9a01.GC9A01(
            self.spi,
            dc=self.dc,
            cs=self.cs,
            reset=self.reset,
            backlight=None,#Pin(7, Pin.OUT),
            rotation=0)
        self.tft.fill(blue)

    def show(self,text,fonts):
#    tft.blit_buffer(triangle.BITMAP,0,0,240,240)
        self.tft.fill(blue)
#        print("paint blue")
        for font in fonts:
            layout=self.layout_text_circular(text,font.WIDTH+1,font.HEIGHT+1)
            if layout is None:
                continue
            for line in layout:
                self.tft.text(font,line[2],
                    line[0],
                    line[1],
                    gc9a01.WHITE,blue
                )
            return
        
    
    def layout_text_circular(self,
        text,
        font_width,
        font_height
    ):
    #this function generated by GPT
        """
        Wrap and center text for a circular screen.

        :param text: The full text to render.
        :param font_width: Width of each character in pixels.
        :param font_height: Height of each text line in pixels.
        :param screen_diameter: Diameter of the circular screen in pixels.
        :return: A list of (x, y, line_text) tuples.
        """
        screen_diameter=self.tft.height
        radius = self.tft.height / 2
        center_y = radius
        words = text.split()
        lines = []
        i = 0
        y_offsets = []

        # Build up vertical line positions (top to bottom)
        max_lines = int(screen_diameter / font_height)
        start_y = center_y - (max_lines / 2) * font_height
        y_positions = [start_y + i * font_height for i in range(max_lines)]

        current_line = ""
        word_index = 0

        for y in y_positions:
            dy = abs(y - center_y)
            if dy >= radius:
                continue  # Outside circle

            max_line_pixel_width = 2 * math.sqrt(radius**2 - dy**2)
            max_chars = int(max_line_pixel_width / font_width)

            line = ""
            while word_index < len(words):
                test_line = line + (" " if line else "") + words[word_index]
                if len(test_line) <= max_chars:
                    line = test_line
                    word_index += 1
                else:
                    break

            if line:
                line_pixel_width = len(line) * font_width
                x = (screen_diameter - line_pixel_width) / 2
                lines.append((int(x), int(y), line))

            if word_index >= len(words):
                break

        return lines if word_index >= len(words) else None
